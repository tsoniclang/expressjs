// Generated by tsbindgen - Architecture
// Namespace: express
// Assembly: express

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { Dictionary_2, IEnumerable_1, List_1 } from "@tsonic/dotnet/System.Collections.Generic/internal/index.js";
import type { Stream } from "@tsonic/dotnet/System.IO/internal/index.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization/internal/index.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization/internal/index.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks/internal/index.js";
import * as System_Internal from "@tsonic/dotnet/System/internal/index.js";
import type { Action, Action_1, Action_2, AsyncCallback, Boolean as ClrBoolean, Byte, DateTime, Exception, IAsyncResult, ICloneable, Int32, Int64, IntPtr, MulticastDelegate, Nullable_1, Object as ClrObject, String as ClrString, Void } from "@tsonic/dotnet/System/internal/index.js";

export type CookieEncoder = (value: string) => string;


export type ErrorRequestHandler = (err: Exception, req: Request, res: Response, next: NextFunction) => Promise<void>;


export type MediaTypeMatcher = (req: Request) => boolean;


export type NextFunction = (control?: string) => Promise<void>;


export type ParamHandler = (req: Request, res: Response, next: NextFunction, value: unknown, name: string) => Promise<void>;


export type QueryParser = (queryString: string) => unknown | undefined;


export type RequestHandler = (req: Request, res: Response, next: NextFunction) => Promise<void>;


export type SetHeadersHandler = (res: Response, path: string, stat: FileStat) => void;


export type TemplateEngine = (path: string, options: Dictionary_2<System_Internal.String, unknown>, callback: Action_2<Exception, System_Internal.String>) => void;


export type TrustProxyEvaluator = (ip: string) => boolean;


export type VerifyBodyHandler = (req: Request, res: Response, buffer: byte[], encoding: string) => void;


export interface Application$instance extends Router {
    readonly __tsonic_type_express_Application: never;

    readonly locals: Dictionary_2<System_Internal.String, unknown | undefined>;
    mountpath: unknown;
    readonly router: Router;
    disable(name: string): Application;
    disabled(name: string): boolean;
    enable(name: string): Application;
    enabled(name: string): boolean;
    engine(ext: string, callback: TemplateEngine): Application;
    get(name: string): unknown | undefined;
    get(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): Router;
    listen(path: string, callback?: Action): AppServer;
    listen(port: int, callback?: Action): AppServer;
    listen(port: int, host: string, callback?: Action): AppServer;
    listen(port: int, host: string, backlog: int, callback?: Action): AppServer;
    param(names: string[], callback: ParamHandler): Application;
    param(name: string, callback: ParamHandler): Router;
    path(): string;
    render(view: string, callback: Action_2<Exception, System_Internal.String>): void;
    render(view: string, viewLocals: Dictionary_2<System_Internal.String, unknown>, callback: Action_2<Exception, System_Internal.String>): void;
    set(name: string, value: unknown): Application;
}


export const Application: {
    new(): Application;
};


export type Application = Application$instance;

export interface AppServer$instance {
    readonly __tsonic_type_express_AppServer: never;

    readonly host: string | undefined;
    listening: boolean;
    readonly path: string | undefined;
    readonly port: Nullable_1<System_Internal.Int32>;
    close(callback?: Action_1<Exception>): void;
}


export const AppServer: {
    new(port: Nullable_1<System_Internal.Int32>, host: string, path: string, closeAction: Action): AppServer;
};


export type AppServer = AppServer$instance;

export interface ByteRange$instance {
    readonly __tsonic_type_express_ByteRange: never;

    end: long;
    start: long;
}


export const ByteRange: {
    new(): ByteRange;
};


export type ByteRange = ByteRange$instance;

export interface CookieOptions$instance {
    readonly __tsonic_type_express_CookieOptions: never;

    get domain(): string | undefined;
    set domain(value: string | undefined);
    get encode(): CookieEncoder | undefined;
    set encode(value: CookieEncoder | undefined);
    get expires(): Nullable_1<DateTime>;
    set expires(value: Nullable_1<DateTime> | DateTime);
    httpOnly: boolean;
    get maxAge(): Nullable_1<System_Internal.Int64>;
    set maxAge(value: Nullable_1<System_Internal.Int64> | long);
    partitioned: boolean;
    path: string;
    get priority(): string | undefined;
    set priority(value: string | undefined);
    get sameSite(): unknown | undefined;
    set sameSite(value: unknown | undefined);
    secure: boolean;
    signed: boolean;
}


export const CookieOptions: {
    new(): CookieOptions;
};


export type CookieOptions = CookieOptions$instance;

export interface Cookies$instance {
    readonly __tsonic_type_express_Cookies: never;

}


export const Cookies: {
    new(): Cookies;
};


export type Cookies = Cookies$instance & { readonly [key: string]: string | undefined; };

export interface CorsOptions$instance {
    readonly __tsonic_type_express_CorsOptions: never;

    get allowedHeaders(): string[] | undefined;
    set allowedHeaders(value: string[] | undefined);
    credentials: boolean;
    get exposedHeaders(): string[] | undefined;
    set exposedHeaders(value: string[] | undefined);
    get maxAgeSeconds(): Nullable_1<System_Internal.Int32>;
    set maxAgeSeconds(value: Nullable_1<System_Internal.Int32> | int);
    get methods(): string[] | undefined;
    set methods(value: string[] | undefined);
    optionsSuccessStatus: int;
    get origins(): string[] | undefined;
    set origins(value: string[] | undefined);
    preflightContinue: boolean;
}


export const CorsOptions: {
    new(): CorsOptions;
};


export type CorsOptions = CorsOptions$instance;

export interface DownloadOptions$instance {
    readonly __tsonic_type_express_DownloadOptions: never;

    acceptRanges: boolean;
    cacheControl: boolean;
    dotfiles: string;
    headers: Dictionary_2<System_Internal.String, System_Internal.String>;
    immutable: boolean;
    lastModified: boolean;
    maxAge: unknown;
    get root(): string | undefined;
    set root(value: string | undefined);
}


export const DownloadOptions: {
    new(): DownloadOptions;
};


export type DownloadOptions = DownloadOptions$instance;

export interface Files$instance {
    readonly __tsonic_type_express_Files: never;

}


export const Files: {
    new(): Files;
};


export type Files = Files$instance & { readonly [field: string]: UploadedFile[] | undefined; };

export interface FileStat$instance {
    readonly __tsonic_type_express_FileStat: never;

    modifiedAt: DateTime;
    size: long;
}


export const FileStat: {
    new(): FileStat;
};


export type FileStat = FileStat$instance;

export interface JsonOptions$instance {
    readonly __tsonic_type_express_JsonOptions: never;

    inflate: boolean;
    get limit(): unknown | undefined;
    set limit(value: unknown | undefined);
    get reviver(): unknown | undefined;
    set reviver(value: unknown | undefined);
    strict: boolean;
    get type(): unknown | undefined;
    set type(value: unknown | undefined);
    get verify(): VerifyBodyHandler | undefined;
    set verify(value: VerifyBodyHandler | undefined);
}


export const JsonOptions: {
    new(): JsonOptions;
};


export type JsonOptions = JsonOptions$instance;

export interface Multipart$instance {
    readonly __tsonic_type_express_Multipart: never;

    any(): RequestHandler;
    array(name: string, maxCount?: Nullable_1<System_Internal.Int32>): RequestHandler;
    fields(fields: MultipartField[]): RequestHandler;
    none(): RequestHandler;
    single(name: string): RequestHandler;
}


export const Multipart: {
    new(options: MultipartOptions): Multipart;
};


export type Multipart = Multipart$instance;

export interface MultipartField$instance {
    readonly __tsonic_type_express_MultipartField: never;

    get maxCount(): Nullable_1<System_Internal.Int32>;
    set maxCount(value: Nullable_1<System_Internal.Int32> | int);
    name: string;
}


export const MultipartField: {
    new(): MultipartField;
};


export type MultipartField = MultipartField$instance;

export interface MultipartOptions$instance {
    readonly __tsonic_type_express_MultipartOptions: never;

    get maxFileCount(): Nullable_1<System_Internal.Int32>;
    set maxFileCount(value: Nullable_1<System_Internal.Int32> | int);
    get maxFileSizeBytes(): Nullable_1<System_Internal.Int64>;
    set maxFileSizeBytes(value: Nullable_1<System_Internal.Int64> | long);
    type: string;
}


export const MultipartOptions: {
    new(): MultipartOptions;
};


export type MultipartOptions = MultipartOptions$instance;

export interface Params$instance {
    readonly __tsonic_type_express_Params: never;

}


export const Params: {
    new(): Params;
};


export type Params = Params$instance & { readonly [key: string]: string | undefined; };

export interface RangeOptions$instance {
    readonly __tsonic_type_express_RangeOptions: never;

    combine: boolean;
}


export const RangeOptions: {
    new(): RangeOptions;
};


export type RangeOptions = RangeOptions$instance;

export interface RangeResult$instance {
    readonly __tsonic_type_express_RangeResult: never;

    readonly ranges: List_1<ByteRange>;
    type: string;
}


export const RangeResult: {
    new(): RangeResult;
};


export type RangeResult = RangeResult$instance;

export interface RawOptions$instance {
    readonly __tsonic_type_express_RawOptions: never;

    inflate: boolean;
    get limit(): unknown | undefined;
    set limit(value: unknown | undefined);
    get type(): unknown | undefined;
    set type(value: unknown | undefined);
    get verify(): VerifyBodyHandler | undefined;
    set verify(value: VerifyBodyHandler | undefined);
}


export const RawOptions: {
    new(): RawOptions;
};


export type RawOptions = RawOptions$instance;

export interface Request$instance {
    readonly __tsonic_type_express_Request: never;

    get app(): Application | undefined;
    set app(value: Application | undefined);
    baseUrl: string;
    get body(): unknown | undefined;
    set body(value: unknown | undefined);
    readonly cookies: Cookies;
    get file(): UploadedFile | undefined;
    set file(value: UploadedFile | undefined);
    readonly files: Files;
    fresh: boolean;
    host: string;
    hostname: string;
    ip: string;
    ips: List_1<System_Internal.String>;
    method: string;
    originalUrl: string;
    readonly params: Params;
    path: string;
    protocol: string;
    query: Dictionary_2<System_Internal.String, unknown | undefined>;
    get res(): Response | undefined;
    set res(value: Response | undefined);
    get route(): Route | undefined;
    set route(value: Route | undefined);
    readonly secure: boolean;
    signed: boolean;
    readonly signedCookies: Cookies;
    readonly stale: boolean;
    subdomains: List_1<System_Internal.String>;
    xhr: boolean;
    accepts(...types: string[]): unknown | undefined;
    acceptsCharsets(...charsets: string[]): unknown | undefined;
    acceptsEncodings(...encodings: string[]): unknown | undefined;
    acceptsLanguages(...languages: string[]): unknown;
    get(field: string): string | undefined;
    header(field: string): string | undefined;
    is(...types: string[]): unknown | undefined;
    param(name: string): string | undefined;
    range(size: long, options?: RangeOptions): unknown;
    setHeader(name: string, value: string): void;
}


export const Request: {
    new(): Request;
};


export type Request = Request$instance;

export interface Response$instance {
    readonly __tsonic_type_express_Response: never;

    readonly app: Application | undefined;
    headersSent: boolean;
    readonly locals: Dictionary_2<System_Internal.String, unknown | undefined>;
    get req(): Request | undefined;
    set req(value: Request | undefined);
    statusCode: int;
    append(field: string, value: string): Response;
    append(field: string, values: IEnumerable_1<System_Internal.String>): Response;
    attachment(filename?: string): Response;
    clearCookie(name: string, options?: CookieOptions): Response;
    contentType(type: string): Response;
    cookie(name: string, value: unknown, options?: CookieOptions): Response;
    download(path: string, filename?: string, options?: DownloadOptions, fn?: Action_1<Exception>): Response;
    end(data?: unknown, encoding?: string, callback?: Action): Response;
    format(handlers: Dictionary_2<System_Internal.String, Action>): Response;
    get(field: string): string | undefined;
    header(field: string, value: unknown): Response;
    json(body?: unknown): Response;
    jsonp(body?: unknown): Response;
    links(links: Dictionary_2<System_Internal.String, System_Internal.String>): Response;
    location(path: string): Response;
    redirect(path: string): Response;
    redirect(status: int, path: string): Response;
    render(view: string): Response;
    render(view: string, viewLocals: Dictionary_2<System_Internal.String, unknown>): Response;
    render(view: string, callback: Action_2<Exception, System_Internal.String>): Response;
    render(view: string, viewLocals: Dictionary_2<System_Internal.String, unknown>, callback: Action_2<Exception, System_Internal.String>): Response;
    send(body?: unknown): Response;
    sendFile(path: string, options?: SendFileOptions, fn?: Action_1<Exception>): Response;
    sendStatus(code: int): Response;
    set(field: string, value: unknown): Response;
    set(fields: Dictionary_2<System_Internal.String, System_Internal.String>): Response;
    status(code: int): Response;
    type(type: string): Response;
    vary(field: string): Response;
}


export const Response: {
    new(): Response;
};


export type Response = Response$instance;

export interface Route$instance extends RoutingHost_1<Route> {
    readonly __tsonic_type_express_Route: never;

    readonly path: unknown;
    all(callback: RequestHandler, ...callbacks: RequestHandler[]): Route;
    all(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): Route;
    delete(callback: RequestHandler, ...callbacks: RequestHandler[]): Route;
    delete(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): Route;
    get(callback: RequestHandler, ...callbacks: RequestHandler[]): Route;
    get(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): Route;
    options(callback: RequestHandler, ...callbacks: RequestHandler[]): Route;
    options(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): Route;
    patch(callback: RequestHandler, ...callbacks: RequestHandler[]): Route;
    patch(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): Route;
    post(callback: RequestHandler, ...callbacks: RequestHandler[]): Route;
    post(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): Route;
    put(callback: RequestHandler, ...callbacks: RequestHandler[]): Route;
    put(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): Route;
}


export const Route: {
};


export type Route = Route$instance;

export interface Router$instance extends RoutingHost_1<Router> {
    readonly __tsonic_type_express_Router: never;

    param(name: string, callback: ParamHandler): Router;
    use(callback: Router): Router;
    use(callback: RequestHandler, ...callbacks: RequestHandler[]): Router;
    use(path: string, callback: Router): Router;
    use(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): Router;
}


export const Router: {
    new(options: RouterOptions): Router;
};


export type Router = Router$instance;

export interface RouterOptions$instance {
    readonly __tsonic_type_express_RouterOptions: never;

    caseSensitive: boolean;
    mergeParams: boolean;
    strict: boolean;
}


export const RouterOptions: {
    new(): RouterOptions;
};


export type RouterOptions = RouterOptions$instance;

export interface RoutingHost_1$instance<TSelf extends RoutingHost_1<TSelf>> {
    readonly __tsonic_type_express_RoutingHost_1: never;

    all(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    checkout(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    copy(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    delete(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    get(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    head(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    lock_(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    m_search(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    merge(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    method(method: string, path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    mkactivity(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    mkcol(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    move(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    notify(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    options(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    param(name: string, callback: ParamHandler): TSelf;
    patch(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    post(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    purge(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    put(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    report(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    route(path: string): Route;
    search(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    subscribe(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    trace(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    unlock(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    unsubscribe(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    use(callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    use(path: string, callback: RequestHandler, ...callbacks: RequestHandler[]): TSelf;
    useError(callback: ErrorRequestHandler, ...callbacks: ErrorRequestHandler[]): TSelf;
    useError(path: string, callback: ErrorRequestHandler, ...callbacks: ErrorRequestHandler[]): TSelf;
}


export const RoutingHost_1: (abstract new<TSelf extends RoutingHost_1<TSelf>>() => RoutingHost_1<TSelf>) & {
};


export type RoutingHost_1<TSelf extends RoutingHost_1<TSelf>> = RoutingHost_1$instance<TSelf>;

export interface SendFileOptions$instance {
    readonly __tsonic_type_express_SendFileOptions: never;

    acceptRanges: boolean;
    cacheControl: boolean;
    dotfiles: string;
    headers: Dictionary_2<System_Internal.String, System_Internal.String>;
    immutable: boolean;
    lastModified: boolean;
    maxAge: unknown;
    get root(): string | undefined;
    set root(value: string | undefined);
}


export const SendFileOptions: {
    new(): SendFileOptions;
};


export type SendFileOptions = SendFileOptions$instance;

export interface StaticOptions$instance {
    readonly __tsonic_type_express_StaticOptions: never;

    acceptRanges: boolean;
    cacheControl: boolean;
    dotfiles: string;
    etag: boolean;
    get extensions(): unknown | undefined;
    set extensions(value: unknown | undefined);
    fallthrough: boolean;
    immutable: boolean;
    get index(): unknown | undefined;
    set index(value: unknown | undefined);
    lastModified: boolean;
    maxAge: unknown;
    redirect: boolean;
    get setHeaders(): SetHeadersHandler | undefined;
    set setHeaders(value: SetHeadersHandler | undefined);
}


export const StaticOptions: {
    new(): StaticOptions;
};


export type StaticOptions = StaticOptions$instance;

export interface TextOptions$instance {
    readonly __tsonic_type_express_TextOptions: never;

    defaultCharset: string;
    inflate: boolean;
    get limit(): unknown | undefined;
    set limit(value: unknown | undefined);
    get type(): unknown | undefined;
    set type(value: unknown | undefined);
    get verify(): VerifyBodyHandler | undefined;
    set verify(value: VerifyBodyHandler | undefined);
}


export const TextOptions: {
    new(): TextOptions;
};


export type TextOptions = TextOptions$instance;

export interface UploadedFile$instance {
    readonly __tsonic_type_express_UploadedFile: never;

    readonly fieldname: string;
    readonly mimetype: string;
    readonly originalname: string;
    readonly size: long;
    copyToAsync(target: Stream): Task;
    openReadStream(): Stream;
    save(path: string): Task;
}


export const UploadedFile: {
};


export type UploadedFile = UploadedFile$instance;

export interface UrlEncodedOptions$instance {
    readonly __tsonic_type_express_UrlEncodedOptions: never;

    depth: int;
    extended: boolean;
    inflate: boolean;
    get limit(): unknown | undefined;
    set limit(value: unknown | undefined);
    parameterLimit: int;
    get type(): unknown | undefined;
    set type(value: unknown | undefined);
    get verify(): VerifyBodyHandler | undefined;
    set verify(value: VerifyBodyHandler | undefined);
}


export const UrlEncodedOptions: {
    new(): UrlEncodedOptions;
};


export type UrlEncodedOptions = UrlEncodedOptions$instance;

export abstract class express$instance {
    static app(): Application;
    static application(): Application;
    static cookieParser(secret: string): RequestHandler;
    static cors(options?: CorsOptions): RequestHandler;
    static create(): Application;
    static json(options?: JsonOptions): RequestHandler;
    static multipart(options?: MultipartOptions): Multipart;
    static raw(options?: RawOptions): RequestHandler;
    static Router(options?: RouterOptions): Router;
    static static(root: string, options?: StaticOptions): RequestHandler;
    static text(options?: TextOptions): RequestHandler;
    static urlencoded(options?: UrlEncodedOptions): RequestHandler;
}


export type express = express$instance;

